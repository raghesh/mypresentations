\documentclass[9pt]{beamer}
\input{header}

\title{\Large{Memory Consistency Models}}
\author[Raghesh A]{\Large{Raghesh A }(CS12D015)\newline\newline
                   %\footnotesize{Guide: V Krishna Nandivada}
}
\institute{PACE Lab, Department of CSE, IIT Madras}
\date{\today}

\begin{document}

% slide
\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Why ...?}
\begin{itemize}
\item Multithreaded programs run on either
  \begin{itemize}
  \item a Uniprocessor \pause OR
  \item Multicores.
  \end{itemize}
\pause
\item One simple way to argue about the correctness of multithreaded programs
      is by looking at the output produced.
\pause
\item Multiple outputs may be acceptable.
\pause
\item The indeterministic nature of multithreaded programs makes programmer's
      life difficult to ensure correctness.
\pause
  \begin{itemize}
  \item One common approach is to apply synchronization.
  \item But the degree of synchronization must be minimal.
  \item Basically synchronization controls the order of read and write to
        shared memory locations.
  \item Without sychronization the order of read and writes may be altered either
        by compiler (optmizations) or by hardware for better performance.
  \end{itemize}
\pause
\item The objective.
  \begin{itemize}
  \item Less compromise on performance - With less degree of synchronization 
  shall we get acceptable output ????
  \item Arguing about the correctness of the program.
  \end{itemize}

\end{itemize}
\end{frame}

\begin{frame}{Memory Model}
\begin{itemize}
\item A formal specification of how the memory system will appear to the programmer.
\item Eliminating gap between expected behaviour (by the programmer) and the
      actual behaviour.
\item Essentially, a \textbf{Memory Model} defines the legitimate orderings of read and write
      to memory locations.
\pause
  \begin{itemize}
  \item A strict memory model - Easy to argue about correctness, but restricts
        optimizations (both at compiler and hardware level).
  \item A relaxed memory model - More opportunities for optimizations, but not
        easy to argue correctness.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Sequential Consistency (SC)}
\begin{itemize}
\item Uniprocessor - A "read" returns the last "write" in program order.
\item Multiprocessor - A "read" may/may not return a value according to "writes" in program order.
  \begin{itemize}
  \item Affected by cache coherency, use of write-buffers, register allocation, ...
  \end{itemize}
\pause
\item \textbf{Sequential consistency} - An intuitive extension of uniprocessor model.
\begin{itemize}
\item \txcolrb{Program order}: Each core executes statements in program order. 
\item Cores are switched in an arbitrary (indeterministic) manner.
\item \txcolrb{Atomicity}: A memory operation executes atomically w.r.t. other memory operations.
\end{itemize}
\pause
\item \underline{An Example}~\cite{Adve2010}\\
\begin{figure}
\small
\centering
Initially $X=Y=0$\\
\begin{tabular} {l | l }
\hline
\txcolr{Red} Thread & \txcolb{Blue} Thread \\
\hline
\txcolr{X = 1;}  & \txcolb{Y = 1;} \\
\txcolr{r1 = Y;} & \txcolb{r2 = X;}\\
\hline
\end{tabular}
\end{figure}
\pause
\item Some possible interleavings.

\begin{figure}
\small
\centering
\begin{tabular} {l | l | l}
\hline
Execution 1 & Execution 2 & Execution 3\\
\hline
\txcolr{X = 1;}       & \txcolb{Y = 1;}       & \txcolr{X = 1;} \\
\txcolr{r1 = Y;}      & \txcolb{r2 = X;}      & \txcolb{Y = 1;}\\
\txcolb{Y = 1;}       & \txcolr{X = 1;}       & \txcolr{r1 = Y;} \\
\txcolb{r2 = X;}      & \txcolr{r1 = Y;}      & \txcolb{r2 = X;}\\
//\txcolr{r1} == 0;   & //\txcolr{r1} == 1;    & //\txcolr{r1} == 1; \\
//\txcolb{r2} == 1;   & //\txcolb{r2} == 0;    & //\txcolb{r2} == 1;\\
\hline
\end{tabular}
\end{figure}

\end{itemize}
\end{frame}

\begin{frame}{Relaxed Consistency (RC)}
\begin{itemize}
\item SC is hard to realize.
\item Too much restriction for hardware and compiler optmizations
\item Even SC may not always produce correct output.
\item So we can live with \textbf{Relaxed Consistency Models}.
\pause
\item Potential relaxations~\cite{rajeev-utah}
  \begin{itemize}
  \item Program order: (Refers to different memory locations)
    \begin{itemize}
    \item Relax $W \rightarrow R$ program order.
    \item Relax $W \rightarrow W$ program order.
    \item Relax $R \rightarrow R$ and $R \rightarrow W$ program order.
    \end{itemize}
\pause
  \item Write atomicity: (Refers to same memory location)
    \begin{itemize}
    \item Read others' write early.
    \end{itemize}
\pause
  \item Write atomicity and program order.
    \begin{itemize}
    \item Read own write early
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Total Store Order (TSO)}
\underline{\textbf{Definition}}~\cite{rajeev-utah}:\\
\begin{enumerate}
\item A read can complete before an earlier write to a different address.
\item A read can not return the value of a write by another processor unless all
      processors have seen the write.
\item A read can return the value of own write before others see it (Makes use of store buffers).
\end{enumerate}
\pause
\begin{figure}
\small
\begin{tabular}{|l|p{1.2cm}|p{1.2cm}|p{1.3cm}|p{1.2cm}|p{1.2cm}|}
\hline
Model & $W \rightarrow R$ order & $W \rightarrow W$ order & $R \rightarrow RW$ order & R Others' W Early & R Own W Early\\
\hline
TSO   & $\surd$                 &                         &                          &                   & $\surd$      \\
\hline
\end{tabular}
\end{figure}
\pause
\begin{itemize}
\item \underline{An Example}\\
\begin{figure}
\small
\centering
Initially $X=Y=0$\\
\begin{tabular} {l | l }
\hline
\txcolr{Red} Thread & \txcolb{Blue} Thread \\
\hline
\txcolr{X = 1;}  & \txcolb{Y = 1;} \\
\txcolr{r1 = Y;} & \txcolb{r2 = X;}\\
\hline
\end{tabular}
\end{figure}
\pause
\item Some possible interleavings (in addition to that of SC).
\begin{minipage}{0.4\textwidth}
\begin{figure}
\centering
\small
\begin{tabular} {|l|l|}
\hline
Time & Execution 1 \\
\hline
$t_1$ & \txcolr{r1 = Y;}   \\
\hline
$t_2 = t_1 + \delta$ & \txcolr{X = 1;}    \\
\hline
$t_2 = t_1 + \delta$ & \txcolb{Y = 1;}     \\
\hline
$t_3 = t_2 + \delta$  & \txcolb{r2 = X;}   \\
\hline
                     &//\txcolr{r1} == 0;\\
\hline
                     &//\txcolb{r2} == 1;\\
\hline
\end{tabular}
\end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{itemize}
\item Effect of 1: It is possible to reorder read to \txcolr{Y} before write to \txcolr{X}.
\item Effect of 2: It is impossible to get value of \txcolb{r2} as 0, by reading 0 from \txcolb{X},
      because an earlier write to \txcolr{X} by \txcolr{Red} thread should have seen by the \txcolb{Blue}
      thread.
\end{itemize}
\end{minipage}
\pause
\small
\item r1 = 0 and r2 = 0 is possible in TSO, but not in SC !!!
\end{itemize}

\end{frame}

\begin{frame}{Correctness of RC}
\underline{Paper}\\
Effective Program Verification for Relaxed Memory Models, by Sebastian Burckhardt and
Madanlal Musuvanthi~\cite{Burckhardt2008}.
\begin{itemize}
\item Same program may exhibit more executions on
      a relaxed model than SC.
\item Let $T_{\Pi}^Y$ be the set of executions of program $\Pi$ on memory model Y.
        Then $T_{\Pi}^{SC} \subset T_{\Pi}^Y$~.
\item To verify relaxed executions \rlxset{}, verify following two problems.
  \begin{itemize}
  \item Use standard verification methodology for concurrent programs to show that
        the executions in \scset{} are correct.
  \item Use specialized methodology for {\em memory model safety} verification
        showing that \rlxset{} $=$ \scset{}.
  \item The program is $Y-safe$  if \rlxset{} $=$ \scset{}.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Correctness of RC~}
\begin{itemize}
\item Generally usage {\em Store buffers} corresponds to TSO.
\item This paper uses TSO-safety and store-buffer-safety interchangably.
\item \textbf{Borderline execution} - SC execution extended into $T_{\Pi}^{TSO} \setminus  T_{\Pi}^{SC}$.
\item A program is store-buffer-safe exactly if there are no borderline executions.
\end{itemize}

\end{frame}

\begin{frame}{Correctness of RC~}
\begin{itemize}
\item Problem formulation.
	\begin{itemize}
	\item {\em A trace} - A collection of events, each representing a memory access
	      (Store, load or interlocked operation).
	\item {\em Issue index} - Sequence number relative to all events by the same processor.
	\item {\em Coherence index} - Sequence number of the value that is read or written
        by the event, relative to the entire value sequence written to the targeted memory 
			  location during the execution.	
	\end{itemize}
\item Formally: \\
\hspace{2cm}$Op = \{st, ld, il\}$, $\mathbb{N} = $set of natural numbers\\
\hspace{2cm}$Proc = {1,...,N}$, finite set of processor ids, $N \in \mathbb{N}$.\\
\hspace{2cm}$Adr$ - fininte set of memory addresses.\\
\hspace{2cm}$\mathbb{N}_0 \subset \mathbb{Z}$ - set of non negative integers

Then\\
\hspace{2cm}$Evt = Op \times Proc \times \mathbb{N} \times Adr \times \mathbb{N}_0$


              
\end{itemize}
\end{frame}

\begin{frame}{Linearisability}
\end{frame}




\footnotesize{
\bibliographystyle{unsrt}
\bibliography{memmodel}
}

\end{document} 
